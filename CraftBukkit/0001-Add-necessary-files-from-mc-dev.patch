From cddf547370cb633b6f7179c3b27de66d9323f774 Mon Sep 17 00:00:00 2001
From: mrapple <tony@oc.tc>
Date: Tue, 18 Dec 2012 22:12:16 -0600
Subject: [PATCH] Add necessary files from mc-dev


diff --git a/src/main/java/net/minecraft/server/BlockFalling.java b/src/main/java/net/minecraft/server/BlockFalling.java
new file mode 100644
index 0000000..1d5fe2f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFalling.java
@@ -0,0 +1,83 @@
+package net.minecraft.server;
+
+import java.util.Random;
+import net.minecraft.server.Block;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.CreativeModeTab;
+import net.minecraft.server.EntityFallingBlock;
+import net.minecraft.server.Material;
+import net.minecraft.server.World;
+
+public class BlockFalling extends Block {
+
+    public static boolean instaFall;
+
+
+    public BlockFalling() {
+        super(Material.SAND);
+        this.a(CreativeModeTab.b);
+    }
+
+    public BlockFalling(Material var1) {
+        super(var1);
+    }
+
+    public void onPlace(World var1, int var2, int var3, int var4) {
+        var1.a(var2, var3, var4, this, this.a(var1));
+    }
+
+    public void doPhysics(World var1, int var2, int var3, int var4, Block var5) {
+        var1.a(var2, var3, var4, this, this.a(var1));
+    }
+
+    public void a(World var1, int var2, int var3, int var4, Random var5) {
+        if (!var1.isStatic) {
+            this.m(var1, var2, var3, var4);
+        }
+    }
+
+    private void m(World var1, int var2, int var3, int var4) {
+        if (canFall(var1, var2, var3 - 1, var4) && var3 >= 0) {
+            byte var8 = 32;
+
+            if (!instaFall && var1.b(var2 - var8, var3 - var8, var4 - var8, var2 + var8, var3 + var8, var4 + var8)) {
+                if (!var1.isStatic) {
+                    EntityFallingBlock var9 = new EntityFallingBlock(var1, (double)((float)var2 + 0.5F), (double)((float)var3 + 0.5F), (double)((float)var4 + 0.5F), this, var1.getData(var2, var3, var4));
+                    this.a(var9);
+                    var1.addEntity(var9);
+                }
+            } else {
+                var1.setAir(var2, var3, var4);
+
+                while (canFall(var1, var2, var3 - 1, var4) && var3 > 0) {
+                    --var3;
+                }
+
+                if (var3 > 0) {
+                    var1.setTypeUpdate(var2, var3, var4, this);
+                }
+            }
+        }
+    }
+
+    protected void a(EntityFallingBlock var1) {}
+
+    public int a(World var1) {
+        return 2;
+    }
+
+    public static boolean canFall(World var0, int var1, int var2, int var3) {
+        Block var4 = var0.getType(var1, var2, var3);
+
+        if (var4.material == Material.AIR) {
+            return true;
+        } else if (var4 == Blocks.FIRE) {
+            return true;
+        } else {
+            Material var5 = var4.material;
+            return var5 == Material.WATER ? true : var5 == Material.LAVA;
+        }
+    }
+
+    public void a(World var1, int var2, int var3, int var4, int var5) {}
+}
diff --git a/src/main/java/net/minecraft/server/BlockFluids.java b/src/main/java/net/minecraft/server/BlockFluids.java
new file mode 100644
index 0000000..c28eb62
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFluids.java
@@ -0,0 +1,239 @@
+package net.minecraft.server;
+
+import java.util.Random;
+import net.minecraft.server.AxisAlignedBB;
+import net.minecraft.server.Block;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Entity;
+import net.minecraft.server.IBlockAccess;
+import net.minecraft.server.Item;
+import net.minecraft.server.Material;
+import net.minecraft.server.Vec3D;
+import net.minecraft.server.World;
+
+public abstract class BlockFluids extends Block {
+
+    protected BlockFluids(Material var1) {
+        super(var1);
+        float var2 = 0.0F;
+        float var3 = 0.0F;
+        this.a(0.0F + var3, 0.0F + var2, 0.0F + var3, 1.0F + var3, 1.0F + var2, 1.0F + var3);
+        this.a(true);
+    }
+
+    public boolean b(IBlockAccess var1, int var2, int var3, int var4) {
+        return this.material != Material.LAVA;
+    }
+
+    public static float b(int var0) {
+        if (var0 >= 8) {
+            var0 = 0;
+        }
+
+        return (float)(var0 + 1) / 9.0F;
+    }
+
+    protected int e(World var1, int var2, int var3, int var4) {
+        return var1.getType(var2, var3, var4).getMaterial() == this.material ? var1.getData(var2, var3, var4) : -1;
+    }
+
+    protected int e(IBlockAccess var1, int var2, int var3, int var4) {
+        if (var1.getType(var2, var3, var4).getMaterial() != this.material) {
+            return -1;
+        } else {
+            int var5 = var1.getData(var2, var3, var4);
+
+            if (var5 >= 8) {
+                var5 = 0;
+            }
+
+            return var5;
+        }
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean a(int var1, boolean var2) {
+        return var2 && var1 == 0;
+    }
+
+    public boolean d(IBlockAccess var1, int var2, int var3, int var4, int var5) {
+        Material var6 = var1.getType(var2, var3, var4).getMaterial();
+        return var6 == this.material ? false : (var5 == 1 ? true : (var6 == Material.ICE ? false : super.d(var1, var2, var3, var4, var5)));
+    }
+
+    public AxisAlignedBB a(World var1, int var2, int var3, int var4) {
+        return null;
+    }
+
+    public int b() {
+        return 4;
+    }
+
+    public Item getDropType(int var1, Random var2, int var3) {
+        return null;
+    }
+
+    public int a(Random var1) {
+        return 0;
+    }
+
+    private Vec3D f(IBlockAccess var1, int var2, int var3, int var4) {
+        Vec3D var5 = var1.getVec3DPool().create(0.0D, 0.0D, 0.0D);
+        int var6 = this.e(var1, var2, var3, var4);
+
+        for (int var7 = 0; var7 < 4; ++var7) {
+            int var8 = var2;
+            int var10 = var4;
+
+            if (var7 == 0) {
+                var8 = var2 - 1;
+            }
+
+            if (var7 == 1) {
+                var10 = var4 - 1;
+            }
+
+            if (var7 == 2) {
+                ++var8;
+            }
+
+            if (var7 == 3) {
+                ++var10;
+            }
+
+            int var11 = this.e(var1, var8, var3, var10);
+            int var12;
+
+            if (var11 < 0) {
+                if (!var1.getType(var8, var3, var10).getMaterial().isSolid()) {
+                    var11 = this.e(var1, var8, var3 - 1, var10);
+
+                    if (var11 >= 0) {
+                        var12 = var11 - (var6 - 8);
+                        var5 = var5.add((double)((var8 - var2) * var12), (double)((var3 - var3) * var12), (double)((var10 - var4) * var12));
+                    }
+                }
+            } else if (var11 >= 0) {
+                var12 = var11 - var6;
+                var5 = var5.add((double)((var8 - var2) * var12), (double)((var3 - var3) * var12), (double)((var10 - var4) * var12));
+            }
+        }
+
+        if (var1.getData(var2, var3, var4) >= 8) {
+            boolean var13 = false;
+
+            if (var13 || this.d(var1, var2, var3, var4 - 1, 2)) {
+                var13 = true;
+            }
+
+            if (var13 || this.d(var1, var2, var3, var4 + 1, 3)) {
+                var13 = true;
+            }
+
+            if (var13 || this.d(var1, var2 - 1, var3, var4, 4)) {
+                var13 = true;
+            }
+
+            if (var13 || this.d(var1, var2 + 1, var3, var4, 5)) {
+                var13 = true;
+            }
+
+            if (var13 || this.d(var1, var2, var3 + 1, var4 - 1, 2)) {
+                var13 = true;
+            }
+
+            if (var13 || this.d(var1, var2, var3 + 1, var4 + 1, 3)) {
+                var13 = true;
+            }
+
+            if (var13 || this.d(var1, var2 - 1, var3 + 1, var4, 4)) {
+                var13 = true;
+            }
+
+            if (var13 || this.d(var1, var2 + 1, var3 + 1, var4, 5)) {
+                var13 = true;
+            }
+
+            if (var13) {
+                var5 = var5.a().add(0.0D, -6.0D, 0.0D);
+            }
+        }
+
+        var5 = var5.a();
+        return var5;
+    }
+
+    public void a(World var1, int var2, int var3, int var4, Entity var5, Vec3D var6) {
+        Vec3D var7 = this.f(var1, var2, var3, var4);
+        var6.c += var7.c;
+        var6.d += var7.d;
+        var6.e += var7.e;
+    }
+
+    public int a(World var1) {
+        return this.material == Material.WATER ? 5 : (this.material == Material.LAVA ? (var1.worldProvider.g ? 10 : 30) : 0);
+    }
+
+    public void onPlace(World var1, int var2, int var3, int var4) {
+        this.n(var1, var2, var3, var4);
+    }
+
+    public void doPhysics(World var1, int var2, int var3, int var4, Block var5) {
+        this.n(var1, var2, var3, var4);
+    }
+
+    private void n(World var1, int var2, int var3, int var4) {
+        if (var1.getType(var2, var3, var4) == this) {
+            if (this.material == Material.LAVA) {
+                boolean var5 = false;
+
+                if (var5 || var1.getType(var2, var3, var4 - 1).getMaterial() == Material.WATER) {
+                    var5 = true;
+                }
+
+                if (var5 || var1.getType(var2, var3, var4 + 1).getMaterial() == Material.WATER) {
+                    var5 = true;
+                }
+
+                if (var5 || var1.getType(var2 - 1, var3, var4).getMaterial() == Material.WATER) {
+                    var5 = true;
+                }
+
+                if (var5 || var1.getType(var2 + 1, var3, var4).getMaterial() == Material.WATER) {
+                    var5 = true;
+                }
+
+                if (var5 || var1.getType(var2, var3 + 1, var4).getMaterial() == Material.WATER) {
+                    var5 = true;
+                }
+
+                if (var5) {
+                    int var6 = var1.getData(var2, var3, var4);
+
+                    if (var6 == 0) {
+                        var1.setTypeUpdate(var2, var3, var4, Blocks.OBSIDIAN);
+                    } else if (var6 <= 4) {
+                        var1.setTypeUpdate(var2, var3, var4, Blocks.COBBLESTONE);
+                    }
+
+                    this.fizz(var1, var2, var3, var4);
+                }
+            }
+        }
+    }
+
+    protected void fizz(World var1, int var2, int var3, int var4) {
+        var1.makeSound((double)((float)var2 + 0.5F), (double)((float)var3 + 0.5F), (double)((float)var4 + 0.5F), "random.fizz", 0.5F, 2.6F + (var1.random.nextFloat() - var1.random.nextFloat()) * 0.8F);
+
+        for (int var5 = 0; var5 < 8; ++var5) {
+            var1.addParticle("largesmoke", (double)var2 + Math.random(), (double)var3 + 1.2D, (double)var4 + Math.random(), 0.0D, 0.0D, 0.0D);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockTNT.java b/src/main/java/net/minecraft/server/BlockTNT.java
new file mode 100644
index 0000000..d690ebe
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockTNT.java
@@ -0,0 +1,90 @@
+package net.minecraft.server;
+
+import java.util.Random;
+import net.minecraft.server.Block;
+import net.minecraft.server.CreativeModeTab;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityArrow;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityLiving;
+import net.minecraft.server.EntityTNTPrimed;
+import net.minecraft.server.Explosion;
+import net.minecraft.server.Items;
+import net.minecraft.server.Material;
+import net.minecraft.server.World;
+
+public class BlockTNT extends Block {
+
+    public BlockTNT() {
+        super(Material.TNT);
+        this.a(CreativeModeTab.d);
+    }
+
+    public void onPlace(World var1, int var2, int var3, int var4) {
+        super.onPlace(var1, var2, var3, var4);
+
+        if (var1.isBlockIndirectlyPowered(var2, var3, var4)) {
+            this.postBreak(var1, var2, var3, var4, 1);
+            var1.setAir(var2, var3, var4);
+        }
+    }
+
+    public void doPhysics(World var1, int var2, int var3, int var4, Block var5) {
+        if (var1.isBlockIndirectlyPowered(var2, var3, var4)) {
+            this.postBreak(var1, var2, var3, var4, 1);
+            var1.setAir(var2, var3, var4);
+        }
+    }
+
+    public int a(Random var1) {
+        return 1;
+    }
+
+    public void wasExploded(World var1, int var2, int var3, int var4, Explosion var5) {
+        if (!var1.isStatic) {
+            EntityTNTPrimed var6 = new EntityTNTPrimed(var1, (double)((float)var2 + 0.5F), (double)((float)var3 + 0.5F), (double)((float)var4 + 0.5F), var5.c());
+            var6.fuseTicks = var1.random.nextInt(var6.fuseTicks / 4) + var6.fuseTicks / 8;
+            var1.addEntity(var6);
+        }
+    }
+
+    public void postBreak(World var1, int var2, int var3, int var4, int var5) {
+        this.a(var1, var2, var3, var4, var5, (EntityLiving)null);
+    }
+
+    public void a(World var1, int var2, int var3, int var4, int var5, EntityLiving var6) {
+        if (!var1.isStatic) {
+            if ((var5 & 1) == 1) {
+                EntityTNTPrimed var7 = new EntityTNTPrimed(var1, (double)((float)var2 + 0.5F), (double)((float)var3 + 0.5F), (double)((float)var4 + 0.5F), var6);
+                var1.addEntity(var7);
+                var1.makeSound(var7, "game.tnt.primed", 1.0F, 1.0F);
+            }
+        }
+    }
+
+    public boolean interact(World var1, int var2, int var3, int var4, EntityHuman var5, int var6, float var7, float var8, float var9) {
+        if (var5.bD() != null && var5.bD().getItem() == Items.FLINT_AND_STEEL) {
+            this.a(var1, var2, var3, var4, 1, var5);
+            var1.setAir(var2, var3, var4);
+            var5.bD().damage(1, var5);
+            return true;
+        } else {
+            return super.interact(var1, var2, var3, var4, var5, var6, var7, var8, var9);
+        }
+    }
+
+    public void a(World var1, int var2, int var3, int var4, Entity var5) {
+        if (var5 instanceof EntityArrow && !var1.isStatic) {
+            EntityArrow var6 = (EntityArrow)var5;
+
+            if (var6.isBurning()) {
+                this.a(var1, var2, var3, var4, 1, var6.shooter instanceof EntityLiving ? (EntityLiving)var6.shooter : null);
+                var1.setAir(var2, var3, var4);
+            }
+        }
+    }
+
+    public boolean a(Explosion var1) {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
new file mode 100644
index 0000000..d90b0e1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -0,0 +1,297 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import net.minecraft.server.ChunkCoordinates;
+import net.minecraft.server.CrashReport;
+import net.minecraft.server.CrashReportSystemDetails;
+import net.minecraft.server.Entity;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.ReportedException;
+import net.minecraft.server.WatchableObject;
+import net.minecraft.util.org.apache.commons.lang3.ObjectUtils;
+
+public class DataWatcher {
+
+    private final Entity a;
+    private boolean b = true;
+    private static final HashMap c = new HashMap();
+    private final Map d = new HashMap();
+    private boolean e;
+    private ReadWriteLock f = new ReentrantReadWriteLock();
+
+
+    public DataWatcher(Entity var1) {
+        this.a = var1;
+    }
+
+    public void a(int var1, Object var2) {
+        Integer var3 = (Integer)c.get(var2.getClass());
+
+        if (var3 == null) {
+            throw new IllegalArgumentException("Unknown data type: " + var2.getClass());
+        } else if (var1 > 31) {
+            throw new IllegalArgumentException("Data value id is too big with " + var1 + "! (Max is " + 31 + ")");
+        } else if (this.d.containsKey(Integer.valueOf(var1))) {
+            throw new IllegalArgumentException("Duplicate id value for " + var1 + "!");
+        } else {
+            WatchableObject var4 = new WatchableObject(var3.intValue(), var1, var2);
+            this.f.writeLock().lock();
+            this.d.put(Integer.valueOf(var1), var4);
+            this.f.writeLock().unlock();
+            this.b = false;
+        }
+    }
+
+    public void a(int var1, int var2) {
+        WatchableObject var3 = new WatchableObject(var2, var1, (Object)null);
+        this.f.writeLock().lock();
+        this.d.put(Integer.valueOf(var1), var3);
+        this.f.writeLock().unlock();
+        this.b = false;
+    }
+
+    public byte getByte(int var1) {
+        return ((Byte)this.i(var1).b()).byteValue();
+    }
+
+    public short getShort(int var1) {
+        return ((Short)this.i(var1).b()).shortValue();
+    }
+
+    public int getInt(int var1) {
+        return ((Integer)this.i(var1).b()).intValue();
+    }
+
+    public float getFloat(int var1) {
+        return ((Float)this.i(var1).b()).floatValue();
+    }
+
+    public String getString(int var1) {
+        return (String)this.i(var1).b();
+    }
+
+    public ItemStack getItemStack(int var1) {
+        return (ItemStack)this.i(var1).b();
+    }
+
+    private WatchableObject i(int var1) {
+        this.f.readLock().lock();
+        WatchableObject var2;
+
+        try {
+            var2 = (WatchableObject)this.d.get(Integer.valueOf(var1));
+        } catch (Throwable var6) {
+            CrashReport var4 = CrashReport.a(var6, "Getting synched entity data");
+            CrashReportSystemDetails var5 = var4.a("Synched entity data");
+            var5.a("Data ID", (Object)Integer.valueOf(var1));
+            throw new ReportedException(var4);
+        }
+
+        this.f.readLock().unlock();
+        return var2;
+    }
+
+    public void watch(int var1, Object var2) {
+        WatchableObject var3 = this.i(var1);
+
+        if (ObjectUtils.notEqual(var2, var3.b())) {
+            var3.a(var2);
+            this.a.i(var1);
+            var3.a(true);
+            this.e = true;
+        }
+    }
+
+    public void h(int var1) {
+        WatchableObject.a(this.i(var1), true);
+        this.e = true;
+    }
+
+    public boolean a() {
+        return this.e;
+    }
+
+    public static void a(List var0, PacketDataSerializer var1) {
+        if (var0 != null) {
+            Iterator var2 = var0.iterator();
+
+            while (var2.hasNext()) {
+                WatchableObject var3 = (WatchableObject)var2.next();
+                a(var1, var3);
+            }
+        }
+
+        var1.writeByte(127);
+    }
+
+    public List b() {
+        ArrayList var1 = null;
+
+        if (this.e) {
+            this.f.readLock().lock();
+            Iterator var2 = this.d.values().iterator();
+
+            while (var2.hasNext()) {
+                WatchableObject var3 = (WatchableObject)var2.next();
+
+                if (var3.d()) {
+                    var3.a(false);
+
+                    if (var1 == null) {
+                        var1 = new ArrayList();
+                    }
+
+                    var1.add(var3);
+                }
+            }
+
+            this.f.readLock().unlock();
+        }
+
+        this.e = false;
+        return var1;
+    }
+
+    public void a(PacketDataSerializer var1) {
+        this.f.readLock().lock();
+        Iterator var2 = this.d.values().iterator();
+
+        while (var2.hasNext()) {
+            WatchableObject var3 = (WatchableObject)var2.next();
+            a(var1, var3);
+        }
+
+        this.f.readLock().unlock();
+        var1.writeByte(127);
+    }
+
+    public List c() {
+        ArrayList var1 = null;
+        this.f.readLock().lock();
+        WatchableObject var3;
+
+        for (Iterator var2 = this.d.values().iterator(); var2.hasNext(); var1.add(var3)) {
+            var3 = (WatchableObject)var2.next();
+
+            if (var1 == null) {
+                var1 = new ArrayList();
+            }
+        }
+
+        this.f.readLock().unlock();
+        return var1;
+    }
+
+    private static void a(PacketDataSerializer var0, WatchableObject var1) {
+        int var2 = (var1.c() << 5 | var1.a() & 31) & 255;
+        var0.writeByte(var2);
+
+        switch (var1.c()) {
+            case 0:
+                var0.writeByte(((Byte)var1.b()).byteValue());
+                break;
+
+            case 1:
+                var0.writeShort(((Short)var1.b()).shortValue());
+                break;
+
+            case 2:
+                var0.writeInt(((Integer)var1.b()).intValue());
+                break;
+
+            case 3:
+                var0.writeFloat(((Float)var1.b()).floatValue());
+                break;
+
+            case 4:
+                var0.a((String)var1.b());
+                break;
+
+            case 5:
+                ItemStack var4 = (ItemStack)var1.b();
+                var0.a(var4);
+                break;
+
+            case 6:
+                ChunkCoordinates var3 = (ChunkCoordinates)var1.b();
+                var0.writeInt(var3.x);
+                var0.writeInt(var3.y);
+                var0.writeInt(var3.z);
+        }
+    }
+
+    public static List b(PacketDataSerializer var0) {
+        ArrayList var1 = null;
+
+        for (byte var2 = var0.readByte(); var2 != 127; var2 = var0.readByte()) {
+            if (var1 == null) {
+                var1 = new ArrayList();
+            }
+
+            int var3 = (var2 & 224) >> 5;
+            int var4 = var2 & 31;
+            WatchableObject var5 = null;
+
+            switch (var3) {
+                case 0:
+                    var5 = new WatchableObject(var3, var4, Byte.valueOf(var0.readByte()));
+                    break;
+
+                case 1:
+                    var5 = new WatchableObject(var3, var4, Short.valueOf(var0.readShort()));
+                    break;
+
+                case 2:
+                    var5 = new WatchableObject(var3, var4, Integer.valueOf(var0.readInt()));
+                    break;
+
+                case 3:
+                    var5 = new WatchableObject(var3, var4, Float.valueOf(var0.readFloat()));
+                    break;
+
+                case 4:
+                    var5 = new WatchableObject(var3, var4, var0.c(32767));
+                    break;
+
+                case 5:
+                    var5 = new WatchableObject(var3, var4, var0.c());
+                    break;
+
+                case 6:
+                    int var6 = var0.readInt();
+                    int var7 = var0.readInt();
+                    int var8 = var0.readInt();
+                    var5 = new WatchableObject(var3, var4, new ChunkCoordinates(var6, var7, var8));
+            }
+
+            var1.add(var5);
+        }
+
+        return var1;
+    }
+
+    public boolean d() {
+        return this.b;
+    }
+
+    public void e() {
+        this.e = false;
+    }
+
+    static {
+        c.put(Byte.class, Integer.valueOf(0));
+        c.put(Short.class, Integer.valueOf(1));
+        c.put(Integer.class, Integer.valueOf(2));
+        c.put(Float.class, Integer.valueOf(3));
+        c.put(String.class, Integer.valueOf(4));
+        c.put(ItemStack.class, Integer.valueOf(5));
+        c.put(ChunkCoordinates.class, Integer.valueOf(6));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NextTickListEntry.java b/src/main/java/net/minecraft/server/NextTickListEntry.java
new file mode 100644
index 0000000..f150b86
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NextTickListEntry.java
@@ -0,0 +1,63 @@
+package net.minecraft.server;
+
+import net.minecraft.server.Block;
+
+public class NextTickListEntry implements Comparable {
+
+    private static long f;
+    private final Block g;
+    public int a;
+    public int b;
+    public int c;
+    public long d;
+    public int e;
+    private long h;
+
+
+    public NextTickListEntry(int var1, int var2, int var3, Block var4) {
+        this.h = (long)(f++);
+        this.a = var1;
+        this.b = var2;
+        this.c = var3;
+        this.g = var4;
+    }
+
+    public boolean equals(Object var1) {
+        if (!(var1 instanceof NextTickListEntry)) {
+            return false;
+        } else {
+            NextTickListEntry var2 = (NextTickListEntry)var1;
+            return this.a == var2.a && this.b == var2.b && this.c == var2.c && Block.a(this.g, var2.g);
+        }
+    }
+
+    public int hashCode() {
+        return (this.a * 1024 * 1024 + this.c * 1024 + this.b) * 256;
+    }
+
+    public NextTickListEntry a(long var1) {
+        this.d = var1;
+        return this;
+    }
+
+    public void a(int var1) {
+        this.e = var1;
+    }
+
+    public int compareTo(NextTickListEntry var1) {
+        return this.d < var1.d ? -1 : (this.d > var1.d ? 1 : (this.e != var1.e ? this.e - var1.e : (this.h < var1.h ? -1 : (this.h > var1.h ? 1 : 0))));
+    }
+
+    public String toString() {
+        return Block.b(this.g) + ": (" + this.a + ", " + this.b + ", " + this.c + "), " + this.d + ", " + this.e + ", " + this.h;
+    }
+
+    public Block a() {
+        return this.g;
+    }
+
+    // $FF: synthetic method
+    public int compareTo(Object var1) {
+        return this.compareTo((NextTickListEntry)var1);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NibbleArray.java b/src/main/java/net/minecraft/server/NibbleArray.java
new file mode 100644
index 0000000..55f3aec
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NibbleArray.java
@@ -0,0 +1,41 @@
+package net.minecraft.server;
+
+
+public class NibbleArray {
+
+    public final byte[] a;
+    private final int b;
+    private final int c;
+
+
+    public NibbleArray(int var1, int var2) {
+        this.a = new byte[var1 >> 1];
+        this.b = var2;
+        this.c = var2 + 4;
+    }
+
+    public NibbleArray(byte[] var1, int var2) {
+        this.a = var1;
+        this.b = var2;
+        this.c = var2 + 4;
+    }
+
+    public int a(int var1, int var2, int var3) {
+        int var4 = var2 << this.c | var3 << this.b | var1;
+        int var5 = var4 >> 1;
+        int var6 = var4 & 1;
+        return var6 == 0 ? this.a[var5] & 15 : this.a[var5] >> 4 & 15;
+    }
+
+    public void a(int var1, int var2, int var3, int var4) {
+        int var5 = var2 << this.c | var3 << this.b | var1;
+        int var6 = var5 >> 1;
+        int var7 = var5 & 1;
+
+        if (var7 == 0) {
+            this.a[var6] = (byte)(this.a[var6] & 240 | var4 & 15);
+        } else {
+            this.a[var6] = (byte)(this.a[var6] & 15 | (var4 & 15) << 4);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/OldChunkLoader.java b/src/main/java/net/minecraft/server/OldChunkLoader.java
new file mode 100644
index 0000000..76f1a9e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/OldChunkLoader.java
@@ -0,0 +1,124 @@
+package net.minecraft.server;
+
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.NBTTagList;
+import net.minecraft.server.NibbleArray;
+import net.minecraft.server.OldChunk;
+import net.minecraft.server.OldNibbleArray;
+import net.minecraft.server.WorldChunkManager;
+
+public class OldChunkLoader {
+
+    public static OldChunk a(NBTTagCompound var0) {
+        int var1 = var0.getInt("xPos");
+        int var2 = var0.getInt("zPos");
+        OldChunk var3 = new OldChunk(var1, var2);
+        var3.g = var0.getByteArray("Blocks");
+        var3.f = new OldNibbleArray(var0.getByteArray("Data"), 7);
+        var3.e = new OldNibbleArray(var0.getByteArray("SkyLight"), 7);
+        var3.d = new OldNibbleArray(var0.getByteArray("BlockLight"), 7);
+        var3.c = var0.getByteArray("HeightMap");
+        var3.b = var0.getBoolean("TerrainPopulated");
+        var3.h = var0.getList("Entities", 10);
+        var3.i = var0.getList("TileEntities", 10);
+        var3.j = var0.getList("TileTicks", 10);
+
+        try {
+            var3.a = var0.getLong("LastUpdate");
+        } catch (ClassCastException var5) {
+            var3.a = (long)var0.getInt("LastUpdate");
+        }
+
+        return var3;
+    }
+
+    public static void a(OldChunk var0, NBTTagCompound var1, WorldChunkManager var2) {
+        var1.setInt("xPos", var0.k);
+        var1.setInt("zPos", var0.l);
+        var1.setLong("LastUpdate", var0.a);
+        int[] var3 = new int[var0.c.length];
+
+        for (int var4 = 0; var4 < var0.c.length; ++var4) {
+            var3[var4] = var0.c[var4];
+        }
+
+        var1.setIntArray("HeightMap", var3);
+        var1.setBoolean("TerrainPopulated", var0.b);
+        NBTTagList var16 = new NBTTagList();
+        int var7;
+
+        for (int var5 = 0; var5 < 8; ++var5) {
+            boolean var6 = true;
+
+            for (var7 = 0; var7 < 16 && var6; ++var7) {
+                int var8 = 0;
+
+                while (var8 < 16 && var6) {
+                    int var9 = 0;
+
+                    while (true) {
+                        if (var9 < 16) {
+                            int var10 = var7 << 11 | var9 << 7 | var8 + (var5 << 4);
+                            byte var11 = var0.g[var10];
+
+                            if (var11 == 0) {
+                                ++var9;
+                                continue;
+                            }
+
+                            var6 = false;
+                        }
+
+                        ++var8;
+                        break;
+                    }
+                }
+            }
+
+            if (!var6) {
+                byte[] var19 = new byte[4096];
+                NibbleArray var20 = new NibbleArray(var19.length, 4);
+                NibbleArray var21 = new NibbleArray(var19.length, 4);
+                NibbleArray var23 = new NibbleArray(var19.length, 4);
+
+                for (int var22 = 0; var22 < 16; ++var22) {
+                    for (int var12 = 0; var12 < 16; ++var12) {
+                        for (int var13 = 0; var13 < 16; ++var13) {
+                            int var14 = var22 << 11 | var13 << 7 | var12 + (var5 << 4);
+                            byte var15 = var0.g[var14];
+                            var19[var12 << 8 | var13 << 4 | var22] = (byte)(var15 & 255);
+                            var20.a(var22, var12, var13, var0.f.a(var22, var12 + (var5 << 4), var13));
+                            var21.a(var22, var12, var13, var0.e.a(var22, var12 + (var5 << 4), var13));
+                            var23.a(var22, var12, var13, var0.d.a(var22, var12 + (var5 << 4), var13));
+                        }
+                    }
+                }
+
+                NBTTagCompound var24 = new NBTTagCompound();
+                var24.setByte("Y", (byte)(var5 & 255));
+                var24.setByteArray("Blocks", var19);
+                var24.setByteArray("Data", var20.a);
+                var24.setByteArray("SkyLight", var21.a);
+                var24.setByteArray("BlockLight", var23.a);
+                var16.add(var24);
+            }
+        }
+
+        var1.set("Sections", var16);
+        byte[] var17 = new byte[256];
+
+        for (int var18 = 0; var18 < 16; ++var18) {
+            for (var7 = 0; var7 < 16; ++var7) {
+                var17[var7 << 4 | var18] = (byte)(var2.getBiome(var0.k << 4 | var18, var0.l << 4 | var7).id & 255);
+            }
+        }
+
+        var1.setByteArray("Biomes", var17);
+        var1.set("Entities", var0.h);
+        var1.set("TileEntities", var0.i);
+
+        if (var0.j != null) {
+            var1.set("TileTicks", var0.j);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutEntityMetadata.java b/src/main/java/net/minecraft/server/PacketPlayOutEntityMetadata.java
new file mode 100644
index 0000000..2ed47fb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutEntityMetadata.java
@@ -0,0 +1,47 @@
+package net.minecraft.server;
+
+import java.util.List;
+import net.minecraft.server.DataWatcher;
+import net.minecraft.server.Packet;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.PacketListener;
+import net.minecraft.server.PacketPlayOutListener;
+
+public class PacketPlayOutEntityMetadata extends Packet {
+
+    private int a;
+    private List b;
+
+
+    public PacketPlayOutEntityMetadata() {}
+
+    public PacketPlayOutEntityMetadata(int var1, DataWatcher var2, boolean var3) {
+        this.a = var1;
+
+        if (var3) {
+            this.b = var2.c();
+        } else {
+            this.b = var2.b();
+        }
+    }
+
+    public void a(PacketDataSerializer var1) {
+        this.a = var1.readInt();
+        this.b = DataWatcher.b(var1);
+    }
+
+    public void b(PacketDataSerializer var1) {
+        var1.writeInt(this.a);
+        DataWatcher.a(this.b, var1);
+    }
+
+    public void a(PacketPlayOutListener var1) {
+        var1.a(this);
+    }
+
+    // $FF: synthetic method
+    // $FF: bridge method
+    public void handle(PacketListener var1) {
+        this.a((PacketPlayOutListener)var1);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
new file mode 100644
index 0000000..234aac4
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -0,0 +1,199 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.util.zip.DataFormatException;
+import java.util.zip.Deflater;
+import java.util.zip.Inflater;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkMap;
+import net.minecraft.server.ChunkSection;
+import net.minecraft.server.NibbleArray;
+import net.minecraft.server.Packet;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.PacketListener;
+import net.minecraft.server.PacketPlayOutListener;
+
+public class PacketPlayOutMapChunk extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private byte[] e;
+    private byte[] buffer;
+    private boolean inflatedBuffer;
+    private int size;
+    private static byte[] buildBuffer = new byte[196864];
+
+
+    public PacketPlayOutMapChunk() {}
+
+    public PacketPlayOutMapChunk(Chunk var1, boolean var2, int var3) {
+        this.a = var1.locX;
+        this.b = var1.locZ;
+        this.inflatedBuffer = var2;
+        ChunkMap var4 = a(var1, var2, var3);
+        Deflater var5 = new Deflater(-1);
+        this.d = var4.c;
+        this.c = var4.b;
+
+        try {
+            this.buffer = var4.a;
+            var5.setInput(var4.a, 0, var4.a.length);
+            var5.finish();
+            this.e = new byte[var4.a.length];
+            this.size = var5.deflate(this.e);
+        } finally {
+            var5.end();
+        }
+    }
+
+    public static int c() {
+        return 196864;
+    }
+
+    public void a(PacketDataSerializer var1) {
+        this.a = var1.readInt();
+        this.b = var1.readInt();
+        this.inflatedBuffer = var1.readBoolean();
+        this.c = var1.readShort();
+        this.d = var1.readShort();
+        this.size = var1.readInt();
+
+        if (buildBuffer.length < this.size) {
+            buildBuffer = new byte[this.size];
+        }
+
+        var1.readBytes(buildBuffer, 0, this.size);
+        int var2 = 0;
+        int var3;
+
+        for (var3 = 0; var3 < 16; ++var3) {
+            var2 += this.c >> var3 & 1;
+        }
+
+        var3 = 12288 * var2;
+
+        if (this.inflatedBuffer) {
+            var3 += 256;
+        }
+
+        this.buffer = new byte[var3];
+        Inflater var4 = new Inflater();
+        var4.setInput(buildBuffer, 0, this.size);
+
+        try {
+            var4.inflate(this.buffer);
+        } catch (DataFormatException var9) {
+            throw new IOException("Bad compressed data format");
+        } finally {
+            var4.end();
+        }
+    }
+
+    public void b(PacketDataSerializer var1) {
+        var1.writeInt(this.a);
+        var1.writeInt(this.b);
+        var1.writeBoolean(this.inflatedBuffer);
+        var1.writeShort((short)(this.c & '\uffff'));
+        var1.writeShort((short)(this.d & '\uffff'));
+        var1.writeInt(this.size);
+        var1.writeBytes(this.e, 0, this.size);
+    }
+
+    public void a(PacketPlayOutListener var1) {
+        var1.a(this);
+    }
+
+    public String b() {
+        return String.format("x=%d, z=%d, full=%b, sects=%d, add=%d, size=%d", new Object[] {Integer.valueOf(this.a), Integer.valueOf(this.b), Boolean.valueOf(this.inflatedBuffer), Integer.valueOf(this.c), Integer.valueOf(this.d), Integer.valueOf(this.size)});
+    }
+
+    public static ChunkMap a(Chunk var0, boolean var1, int var2) {
+        int var3 = 0;
+        ChunkSection[] var4 = var0.i();
+        int var5 = 0;
+        ChunkMap var6 = new ChunkMap();
+        byte[] var7 = buildBuffer;
+
+        if (var1) {
+            var0.q = true;
+        }
+
+        int var8;
+
+        for (var8 = 0; var8 < var4.length; ++var8) {
+            if (var4[var8] != null && (!var1 || !var4[var8].isEmpty()) && (var2 & 1 << var8) != 0) {
+                var6.b |= 1 << var8;
+
+                if (var4[var8].getExtendedIdArray() != null) {
+                    var6.c |= 1 << var8;
+                    ++var5;
+                }
+            }
+        }
+
+        for (var8 = 0; var8 < var4.length; ++var8) {
+            if (var4[var8] != null && (!var1 || !var4[var8].isEmpty()) && (var2 & 1 << var8) != 0) {
+                byte[] var9 = var4[var8].getIdArray();
+                System.arraycopy(var9, 0, var7, var3, var9.length);
+                var3 += var9.length;
+            }
+        }
+
+        NibbleArray var10;
+
+        for (var8 = 0; var8 < var4.length; ++var8) {
+            if (var4[var8] != null && (!var1 || !var4[var8].isEmpty()) && (var2 & 1 << var8) != 0) {
+                var10 = var4[var8].getDataArray();
+                System.arraycopy(var10.a, 0, var7, var3, var10.a.length);
+                var3 += var10.a.length;
+            }
+        }
+
+        for (var8 = 0; var8 < var4.length; ++var8) {
+            if (var4[var8] != null && (!var1 || !var4[var8].isEmpty()) && (var2 & 1 << var8) != 0) {
+                var10 = var4[var8].getEmittedLightArray();
+                System.arraycopy(var10.a, 0, var7, var3, var10.a.length);
+                var3 += var10.a.length;
+            }
+        }
+
+        if (!var0.world.worldProvider.g) {
+            for (var8 = 0; var8 < var4.length; ++var8) {
+                if (var4[var8] != null && (!var1 || !var4[var8].isEmpty()) && (var2 & 1 << var8) != 0) {
+                    var10 = var4[var8].getSkyLightArray();
+                    System.arraycopy(var10.a, 0, var7, var3, var10.a.length);
+                    var3 += var10.a.length;
+                }
+            }
+        }
+
+        if (var5 > 0) {
+            for (var8 = 0; var8 < var4.length; ++var8) {
+                if (var4[var8] != null && (!var1 || !var4[var8].isEmpty()) && var4[var8].getExtendedIdArray() != null && (var2 & 1 << var8) != 0) {
+                    var10 = var4[var8].getExtendedIdArray();
+                    System.arraycopy(var10.a, 0, var7, var3, var10.a.length);
+                    var3 += var10.a.length;
+                }
+            }
+        }
+
+        if (var1) {
+            byte[] var11 = var0.m();
+            System.arraycopy(var11, 0, var7, var3, var11.length);
+            var3 += var11.length;
+        }
+
+        var6.a = new byte[var3];
+        System.arraycopy(var7, 0, var6.a, 0, var3);
+        return var6;
+    }
+
+    // $FF: synthetic method
+    // $FF: bridge method
+    public void handle(PacketListener var1) {
+        this.a((PacketPlayOutListener)var1);
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutWorldParticles.java b/src/main/java/net/minecraft/server/PacketPlayOutWorldParticles.java
new file mode 100644
index 0000000..17c8f1f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutWorldParticles.java
@@ -0,0 +1,68 @@
+package net.minecraft.server;
+
+import net.minecraft.server.Packet;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.PacketListener;
+import net.minecraft.server.PacketPlayOutListener;
+
+public class PacketPlayOutWorldParticles extends Packet {
+
+    private String a;
+    private float b;
+    private float c;
+    private float d;
+    private float e;
+    private float f;
+    private float g;
+    private float h;
+    private int i;
+
+
+    public PacketPlayOutWorldParticles() {}
+
+    public PacketPlayOutWorldParticles(String var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8, int var9) {
+        this.a = var1;
+        this.b = var2;
+        this.c = var3;
+        this.d = var4;
+        this.e = var5;
+        this.f = var6;
+        this.g = var7;
+        this.h = var8;
+        this.i = var9;
+    }
+
+    public void a(PacketDataSerializer var1) {
+        this.a = var1.c(64);
+        this.b = var1.readFloat();
+        this.c = var1.readFloat();
+        this.d = var1.readFloat();
+        this.e = var1.readFloat();
+        this.f = var1.readFloat();
+        this.g = var1.readFloat();
+        this.h = var1.readFloat();
+        this.i = var1.readInt();
+    }
+
+    public void b(PacketDataSerializer var1) {
+        var1.a(this.a);
+        var1.writeFloat(this.b);
+        var1.writeFloat(this.c);
+        var1.writeFloat(this.d);
+        var1.writeFloat(this.e);
+        var1.writeFloat(this.f);
+        var1.writeFloat(this.g);
+        var1.writeFloat(this.h);
+        var1.writeInt(this.i);
+    }
+
+    public void a(PacketPlayOutListener var1) {
+        var1.a(this);
+    }
+
+    // $FF: synthetic method
+    // $FF: bridge method
+    public void handle(PacketListener var1) {
+        this.a((PacketPlayOutListener)var1);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
new file mode 100644
index 0000000..4741e41
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -0,0 +1,67 @@
+package net.minecraft.server;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import net.minecraft.server.RegionFile;
+
+public class RegionFileCache {
+
+    private static final Map a = new HashMap();
+
+
+    public static synchronized RegionFile a(File var0, int var1, int var2) {
+        File var3 = new File(var0, "region");
+        File var4 = new File(var3, "r." + (var1 >> 5) + "." + (var2 >> 5) + ".mca");
+        RegionFile var5 = (RegionFile)a.get(var4);
+
+        if (var5 != null) {
+            return var5;
+        } else {
+            if (!var3.exists()) {
+                var3.mkdirs();
+            }
+
+            if (a.size() >= 256) {
+                a();
+            }
+
+            RegionFile var6 = new RegionFile(var4);
+            a.put(var4, var6);
+            return var6;
+        }
+    }
+
+    public static synchronized void a() {
+        Iterator var0 = a.values().iterator();
+
+        while (var0.hasNext()) {
+            RegionFile var1 = (RegionFile)var0.next();
+
+            try {
+                if (var1 != null) {
+                    var1.c();
+                }
+            } catch (IOException var3) {
+                var3.printStackTrace();
+            }
+        }
+
+        a.clear();
+    }
+
+    public static DataInputStream c(File var0, int var1, int var2) {
+        RegionFile var3 = a(var0, var1, var2);
+        return var3.a(var1 & 31, var2 & 31);
+    }
+
+    public static DataOutputStream d(File var0, int var1, int var2) {
+        RegionFile var3 = a(var0, var1, var2);
+        return var3.b(var1 & 31, var2 & 31);
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/RemoteStatusListener.java b/src/main/java/net/minecraft/server/RemoteStatusListener.java
new file mode 100644
index 0000000..0608580
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RemoteStatusListener.java
@@ -0,0 +1,292 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetAddress;
+import java.net.PortUnreachableException;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import net.minecraft.server.IMinecraftServer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.RemoteConnectionThread;
+import net.minecraft.server.RemoteStatusChallenge;
+import net.minecraft.server.RemoteStatusReply;
+import net.minecraft.server.StatusChallengeUtils;
+
+public class RemoteStatusListener extends RemoteConnectionThread {
+
+    private long clearedTime;
+    private int bindPort;
+    private int serverPort;
+    private int maxPlayers;
+    private String localAddress;
+    private String worldName;
+    private DatagramSocket socket;
+    private byte[] o = new byte[1460];
+    private DatagramPacket p;
+    private Map q;
+    private String hostname;
+    private String motd;
+    private Map challenges;
+    private long u;
+    private RemoteStatusReply cachedReply;
+    private long cacheTime;
+
+
+    public RemoteStatusListener(IMinecraftServer var1) {
+        super(var1, "Query Listener");
+        this.bindPort = var1.a("query.port", 0);
+        this.motd = var1.x();
+        this.serverPort = var1.y();
+        this.localAddress = var1.z();
+        this.maxPlayers = var1.C();
+        this.worldName = var1.M();
+        this.cacheTime = 0L;
+        this.hostname = "0.0.0.0";
+
+        if (0 != this.motd.length() && !this.hostname.equals(this.motd)) {
+            this.hostname = this.motd;
+        } else {
+            this.motd = "0.0.0.0";
+
+            try {
+                InetAddress var2 = InetAddress.getLocalHost();
+                this.hostname = var2.getHostAddress();
+            } catch (UnknownHostException var3) {
+                this.warning("Unable to determine local host IP, please set server-ip in \'" + var1.b() + "\' : " + var3.getMessage());
+            }
+        }
+
+        if (0 == this.bindPort) {
+            this.bindPort = this.serverPort;
+            this.info("Setting default query port to " + this.bindPort);
+            var1.a("query.port", (Object)Integer.valueOf(this.bindPort));
+            var1.a("debug", (Object)Boolean.valueOf(false));
+            var1.a();
+        }
+
+        this.q = new HashMap();
+        this.cachedReply = new RemoteStatusReply(1460);
+        this.challenges = new HashMap();
+        this.u = (new Date()).getTime();
+    }
+
+    private void send(byte[] var1, DatagramPacket var2) {
+        this.socket.send(new DatagramPacket(var1, var1.length, var2.getSocketAddress()));
+    }
+
+    private boolean parsePacket(DatagramPacket var1) {
+        byte[] var2 = var1.getData();
+        int var3 = var1.getLength();
+        SocketAddress var4 = var1.getSocketAddress();
+        this.debug("Packet len " + var3 + " [" + var4 + "]");
+
+        if (3 <= var3 && -2 == var2[0] && -3 == var2[1]) {
+            this.debug("Packet \'" + StatusChallengeUtils.a(var2[2]) + "\' [" + var4 + "]");
+
+            switch (var2[2]) {
+                case 0:
+                    if (!this.hasChallenged(var1).booleanValue()) {
+                        this.debug("Invalid challenge [" + var4 + "]");
+                        return false;
+                    } else if (15 == var3) {
+                        this.send(this.getFullReply(var1), var1);
+                        this.debug("Rules [" + var4 + "]");
+                    } else {
+                        RemoteStatusReply var5 = new RemoteStatusReply(1460);
+                        var5.write((int)0);
+                        var5.write(this.getIdentityToken(var1.getSocketAddress()));
+                        var5.write(this.localAddress);
+                        var5.write("SMP");
+                        var5.write(this.worldName);
+                        var5.write(Integer.toString(this.d()));
+                        var5.write(Integer.toString(this.maxPlayers));
+                        var5.write((short)this.serverPort);
+                        var5.write(this.hostname);
+                        this.send(var5.getBytes(), var1);
+                        this.debug("Status [" + var4 + "]");
+                    }
+
+                case 9:
+                    this.createChallenge(var1);
+                    this.debug("Challenge [" + var4 + "]");
+                    return true;
+
+                default:
+                    return true;
+            }
+        } else {
+            this.debug("Invalid packet [" + var4 + "]");
+            return false;
+        }
+    }
+
+    private byte[] getFullReply(DatagramPacket var1) {
+        long var2 = MinecraftServer.ap();
+
+        if (var2 < this.cacheTime + 5000L) {
+            byte[] var9 = this.cachedReply.getBytes();
+            byte[] var10 = this.getIdentityToken(var1.getSocketAddress());
+            var9[1] = var10[0];
+            var9[2] = var10[1];
+            var9[3] = var10[2];
+            var9[4] = var10[3];
+            return var9;
+        } else {
+            this.cacheTime = var2;
+            this.cachedReply.reset();
+            this.cachedReply.write((int)0);
+            this.cachedReply.write(this.getIdentityToken(var1.getSocketAddress()));
+            this.cachedReply.write("splitnum");
+            this.cachedReply.write((int)128);
+            this.cachedReply.write((int)0);
+            this.cachedReply.write("hostname");
+            this.cachedReply.write(this.localAddress);
+            this.cachedReply.write("gametype");
+            this.cachedReply.write("SMP");
+            this.cachedReply.write("game_id");
+            this.cachedReply.write("MINECRAFT");
+            this.cachedReply.write("version");
+            this.cachedReply.write(this.server.getVersion());
+            this.cachedReply.write("plugins");
+            this.cachedReply.write(this.server.getPlugins());
+            this.cachedReply.write("map");
+            this.cachedReply.write(this.worldName);
+            this.cachedReply.write("numplayers");
+            this.cachedReply.write("" + this.d());
+            this.cachedReply.write("maxplayers");
+            this.cachedReply.write("" + this.maxPlayers);
+            this.cachedReply.write("hostport");
+            this.cachedReply.write("" + this.serverPort);
+            this.cachedReply.write("hostip");
+            this.cachedReply.write(this.hostname);
+            this.cachedReply.write((int)0);
+            this.cachedReply.write((int)1);
+            this.cachedReply.write("player_");
+            this.cachedReply.write((int)0);
+            String[] var4 = this.server.getPlayers();
+            String[] var5 = var4;
+            int var6 = var4.length;
+
+            for (int var7 = 0; var7 < var6; ++var7) {
+                String var8 = var5[var7];
+                this.cachedReply.write(var8);
+            }
+
+            this.cachedReply.write((int)0);
+            return this.cachedReply.getBytes();
+        }
+    }
+
+    private byte[] getIdentityToken(SocketAddress var1) {
+        return ((RemoteStatusChallenge)this.challenges.get(var1)).getIdentityToken();
+    }
+
+    private Boolean hasChallenged(DatagramPacket var1) {
+        SocketAddress var2 = var1.getSocketAddress();
+
+        if (!this.challenges.containsKey(var2)) {
+            return Boolean.valueOf(false);
+        } else {
+            byte[] var3 = var1.getData();
+            return ((RemoteStatusChallenge)this.challenges.get(var2)).getToken() != StatusChallengeUtils.c(var3, 7, var1.getLength()) ? Boolean.valueOf(false) : Boolean.valueOf(true);
+        }
+    }
+
+    private void createChallenge(DatagramPacket var1) {
+        RemoteStatusChallenge var2 = new RemoteStatusChallenge(this, var1);
+        this.challenges.put(var1.getSocketAddress(), var2);
+        this.send(var2.getChallengeResponse(), var1);
+    }
+
+    private void cleanChallenges() {
+        if (this.running) {
+            long var1 = MinecraftServer.ap();
+
+            if (var1 >= this.clearedTime + 30000L) {
+                this.clearedTime = var1;
+                Iterator var3 = this.challenges.entrySet().iterator();
+
+                while (var3.hasNext()) {
+                    Entry var4 = (Entry)var3.next();
+
+                    if (((RemoteStatusChallenge)var4.getValue()).isExpired(var1).booleanValue()) {
+                        var3.remove();
+                    }
+                }
+            }
+        }
+    }
+
+    public void run() {
+        this.info("Query running on " + this.motd + ":" + this.bindPort);
+        this.clearedTime = MinecraftServer.ap();
+        this.p = new DatagramPacket(this.o, this.o.length);
+
+        try {
+            while (this.running) {
+                try {
+                    this.socket.receive(this.p);
+                    this.cleanChallenges();
+                    this.parsePacket(this.p);
+                } catch (SocketTimeoutException var7) {
+                    this.cleanChallenges();
+                } catch (PortUnreachableException var8) {
+                    ;
+                } catch (IOException var9) {
+                    this.a(var9);
+                }
+            }
+        } finally {
+            this.e();
+        }
+    }
+
+    public void a() {
+        if (!this.running) {
+            if (0 < this.bindPort && '\uffff' >= this.bindPort) {
+                if (this.g()) {
+                    super.a();
+                }
+            } else {
+                this.warning("Invalid query port " + this.bindPort + " found in \'" + this.server.b() + "\' (queries disabled)");
+            }
+        }
+    }
+
+    private void a(Exception var1) {
+        if (this.running) {
+            this.warning("Unexpected exception, buggy JRE? (" + var1.toString() + ")");
+
+            if (!this.g()) {
+                this.error("Failed to recover from buggy JRE, shutting down!");
+                this.running = false;
+            }
+        }
+    }
+
+    private boolean g() {
+        try {
+            this.socket = new DatagramSocket(this.bindPort, InetAddress.getByName(this.motd));
+            this.a(this.socket);
+            this.socket.setSoTimeout(500);
+            return true;
+        } catch (SocketException var2) {
+            this.warning("Unable to initialise query system on " + this.motd + ":" + this.bindPort + " (Socket): " + var2.getMessage());
+        } catch (UnknownHostException var3) {
+            this.warning("Unable to initialise query system on " + this.motd + ":" + this.bindPort + " (Unknown Host): " + var3.getMessage());
+        } catch (Exception var4) {
+            this.warning("Unable to initialise query system on " + this.motd + ":" + this.bindPort + " (E): " + var4.getMessage());
+        }
+
+        return false;
+    }
+}
-- 
1.8.3.2

